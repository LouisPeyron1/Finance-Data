# -*- coding: utf-8 -*-
"""Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BuROyLF3eo-urnDruQV6Z9BpY3Ofc47o
"""

from keras.models import Sequential
from keras.layers.core import Dense, Activation, Dropout
from keras.layers import LSTM, BatchNormalization
from tensorflow.python.keras.initializers import RandomUniform
import numpy as np
from pandas import Series, DataFrame, Panel
pd.set_option('display.max_rows',15)
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import numpy as np
from sklearn.datasets import load_digits
from matplotlib import pyplot as plt
from sklearn.decomposition import TruncatedSVD
float_formatter = lambda x: "%.2f" % x
np.set_printoptions(formatter={'float_kind':float_formatter})
from sklearn.ensemble import RandomForestClassifier
import csv
import pandas as pd
from scipy import linalg
from numpy import *
#value is a data frame which can contain all types of information on the value studied (google news trend, volatility, volume, ...). however it is necessary to be careful to modify the time scale with dates = pd. date_range ('2010-01-03', periods = 458, freq = 'W')
#before loaching the prediction function
def prediction(value): #input is the dataframe described, and the output is the test and train score and the plot of both train and testpredict with the real open price of the share
  train,test=createtrain(value)
  TrainX,TrainY=create_dataset(train,look_back=1)
  TestX,TestY=create_dataset(test)
  model = Sequential()
  model.add(Dense(24, input_shape=(2,), activation="linear"))
  model.add(Dense(12, activation="linear"))
  model.add(Dense(1, activation="linear"))
  model.compile(loss='mean_squared_error', optimizer='adam')
  model.fit(TrainX, TrainY, epochs=1000, batch_size=2, verbose=2)
  trainScore = model.evaluate(TrainX, TrainY, verbose=0)
  print('Train Score: %.2f MSE (%.2f RMSE)' % (trainScore, math.sqrt(trainScore)))
  testScore = model.evaluate(TestX, TestY, verbose=0)
  print('Test Score: %.2f MSE (%.2f RMSE)' % (testScore, math.sqrt(testScore)))
  testPredict = model.predict(TestX)
  #Here there is also an other part that can be modify, 
  testPredictPlot = np.zeros(len(value.open)
  for i in range (0,len(value.open)-len(testPredict)):
                             testPredictPlot[i]=TrainY[i]
  for i in range (len(testPredict)):
                             testPredictPlot[len(value.open)-len(testPredict)+i]=testPredict[i]
  plt.plot(dates,value.open)
  plt.plot(dates,testPredictPlot)
  plt.show()

def createtrain(value): #input = dataframe, and the output is both training and testing dataset 
  train_size = int(len(value.open) * 0.75)
  test_size = len(value.open) - train_size
  train=value[0:train_size]
  test=value[train_size:len(value)]
  return train,test

def timeseriesanalysis(open,news,volume,volatility,... ): #input all datasets you want, to see correlation ith the open share price and return a datapframe 
  dates = pd.date_range('2010-01-03', periods=458, freq='W')
  valueW=Series(open,index=dates)
  NvalueW=Series(news,index=dates)
  VvalueW=Series(volatility ,index=dates)
  VolvalueW=Series(volume,index=dates)
                             ...
  value = DataFrame({'open' : valueW, 'volatility' : VvalueW, 'volume':VolvalueW, 'news':NvalueW,...})
  value.plot(subplots=True)
  value.describe()
  value['open'].rolling(window=12, center=False).mean().plot(style='-g')
  value.open.rolling(window=12).corr(other=value.news).plot(style='-g')
  value.open.rolling(window=12).corr(other=value.volatility).plot(style='-g')
  value.open.rolling(window=12).corr(other=value.volume).plot(style='-g')
  print(value.corr())                          
  return(value)
                            

def create_dataset(dataset, look_back=1):#input is traning and testing dataset, created by createtrain, and gives us the training and testing datset we are going to use for prediction
  n=len(dataset)
  dataY=np.zeros(n)
  dataX=np.zeros(shape=(n,2))
  dataY=dataset.iloc[:,[0]]
  dataX=dataset.iloc[:,[1,3]]
  return numpy.array(dataX), numpy.array(dataY)
